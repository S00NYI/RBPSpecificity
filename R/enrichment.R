# Functions related to calculating K-mer motif enrichment from peak data.

#' Calculate Average K-mer Counts from Background Sets
#'
#' @description This function calculates the average K-mer counts over multiple
#'   iterations of background sequence generation. For each iteration, it generates
#'   a new set of background sequences using `generateBkgSet`, counts K-mers
#'   using `countKmers`, and then averages these counts across all iterations.
#'
#' @param original_peak_gr A GRanges object representing the initial peaks from
#'   which background regions are derived.
#' @param K Integer, the length of K-mers to count.
#' @param type Character string, "DNA" or "RNA" (case-insensitive), defining the
#'   alphabet for K-mer generation. Passed to `countKmers` and used to
#'   generate the K-mer universe. Default: "DNA".
#' @param genome_obj A BSgenome object for sequence retrieval by `generateBkgSet`.
#' @param bkg_min_dist Integer, the minimum absolute distance (in base pairs) for
#'   shifting peaks. Passed to `generateBkgSet`. Default: 500.
#' @param bkg_iter Integer, the number of background iterations to perform.
#'   Default: 100.
#' @param bkg_max_dist Integer, the maximum absolute distance (in base pairs)
#'   for shifting peaks. Passed to `generateBkgSet`. Default: 1000.
#' @param internal_min_length_for_bkg_seqs Integer, minimum length for sequences
#'   generated by `generateBkgSet` (passed as `K` to `generateBkgSet` which
#'   passes it as `min_length` to `getSequence`). Default is `K` from this function.
#' @param scramble_bkg Logical, if TRUE (default), scrambles background sequences.
#'   Set to FALSE for faster execution when scrambling is not needed.
#'
#' @return A data frame with two columns: 'MOTIF' (all possible K-mers for the
#'   specified type and K, in uppercase) and 'AVG_BKG_COUNT' (the average count
#'   of each K-mer across all background iterations, rounded).
#'   Returns a data frame with 0 counts if no valid background sequences
#'   could be generated across all iterations.
#'
#' @importFrom Biostrings DNAStringSet
#' @importFrom S4Vectors elementNROWS
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @importFrom methods is
#'
#' @keywords internal # Helper for the main motifEnrichment function
countKmersBkg <- function(original_peak_gr, K, type = "DNA", genome_obj,
                          bkg_min_dist = 500, bkg_iter = 100, bkg_max_dist = 1000,
                          internal_min_length_for_bkg_seqs = K, scramble_bkg = TRUE,
                          chunk_size = NULL) {
  # --- Input Validation ---
  if (!methods::is(original_peak_gr, "GRanges") || length(original_peak_gr) == 0) {
    stop("'original_peak_gr' must be a non-empty GRanges object.")
  }
  if (!is.numeric(bkg_iter) || length(bkg_iter) != 1 || bkg_iter <= 0 || bkg_iter %% 1 != 0) {
    stop("'bkg_iter' must be a single positive integer.")
  }
  if (!is.numeric(internal_min_length_for_bkg_seqs) || length(internal_min_length_for_bkg_seqs) != 1 ||
    internal_min_length_for_bkg_seqs < 1 || internal_min_length_for_bkg_seqs %% 1 != 0) {
    stop("'internal_min_length_for_bkg_seqs' must be a single positive integer.")
  }
  if (internal_min_length_for_bkg_seqs < K) {
    warning(
      "'internal_min_length_for_bkg_seqs' (", internal_min_length_for_bkg_seqs,
      ") is less than K (", K, "). Background sequences might be too short for K-mer counting."
    )
  }

  message("Note: During background generation, any regions shorter than K=", K, " will be removed.")

  # --- Auto-calculate chunk_size for memory safety ---
  if (is.null(chunk_size)) {
    num_peaks <- length(original_peak_gr)
    num_kmers <- 4^K
    # Target ~1 GB for the oligonucleotideFrequency matrix
    # Matrix size per iteration = num_peaks * num_kmers * 4 bytes (integer)
    bytes_per_iter <- as.numeric(num_peaks) * num_kmers * 4
    if (bytes_per_iter > 0) {
      chunk_size <- max(1L, as.integer(floor(1e9 / bytes_per_iter)))
    } else {
      chunk_size <- bkg_iter
    }
    chunk_size <- min(chunk_size, bkg_iter)
  }

  # --- Template k-mers ---
  template_kmers_df <- suppressMessages(countKmers(sequences = Biostrings::DNAStringSet(), K = K, type = type))
  all_kmers_vector <- template_kmers_df$MOTIF

  if (length(all_kmers_vector) == 0 && K > 0) {
    stop("Could not generate the K-mer universe template. Check K and type parameters for countKmers.")
  }

  # --- Accumulator matrix ---
  counts_accumulator_matrix <- matrix(0L,
    nrow = length(all_kmers_vector),
    ncol = bkg_iter,
    dimnames = list(all_kmers_vector, NULL)
  )

  valid_iterations_count <- 0

  message("Generating average background K-mer profile over ", bkg_iter,
          " iterations (chunk_size=", chunk_size, "):")
  pb <- utils::txtProgressBar(min = 0, max = bkg_iter, style = 3)

  # --- Process in chunks ---
  chunk_starts <- seq(1L, bkg_iter, by = chunk_size)

  for (cs in chunk_starts) {
    chunk_end <- min(cs + chunk_size - 1L, bkg_iter)
    n_this_chunk <- chunk_end - cs + 1L

    # Batched background generation for this chunk
    bkg_result <- generateBkgSetBatched(
      peak_gr = original_peak_gr,
      genome_obj = genome_obj,
      min_seq_length = internal_min_length_for_bkg_seqs,
      bkg_min_dist = bkg_min_dist,
      bkg_max_dist = bkg_max_dist,
      scramble = scramble_bkg,
      n_iter = n_this_chunk
    )

    if (length(bkg_result$sequences) > 0) {
      # One oligonucleotideFrequency call for entire chunk
      freq_matrix <- Biostrings::oligonucleotideFrequency(bkg_result$sequences, width = K)

      # Grouped sums via rowsum (C-level, very fast)
      per_iter_sums <- rowsum(freq_matrix, group = bkg_result$iter_tags, reorder = TRUE)

      # Map chunk-local iteration indices to global column indices
      iter_indices_in_chunk <- as.integer(rownames(per_iter_sums))
      global_col_indices <- cs + iter_indices_in_chunk - 1L

      # Store in accumulator (columns of freq_matrix match all_kmers_vector order)
      counts_accumulator_matrix[, global_col_indices] <- t(per_iter_sums)

      # Count valid iterations (those with non-zero total counts)
      iter_totals <- rowSums(per_iter_sums)
      valid_iterations_count <- valid_iterations_count + sum(iter_totals > 0)
    }

    utils::setTxtProgressBar(pb, chunk_end)
  }
  close(pb)

  # --- Averaging and output ---
  if (valid_iterations_count == 0 && bkg_iter > 0) {
    message(
      "\nNOTE: No valid background sequences yielded counts across any of the ", bkg_iter, " iterations. ",
      "Average background counts will be all zeros."
    )
  } else if (bkg_iter > 0) {
    message(
      "\nBackground profile generated. Averaged over ", valid_iterations_count,
      " iterations that yielded sequences with K-mer counts."
    )
  }

  average_counts <- rowMeans(counts_accumulator_matrix, na.rm = FALSE)

  results_df <- data.frame(
    MOTIF = all_kmers_vector,
    AVG_BKG_COUNT = round(average_counts, 4),
    stringsAsFactors = FALSE
  )

  return(results_df)
}


#' Calculate Background-Corrected K-mer Enrichment
#'
#' @description Calculates enrichment scores by comparing K-mer counts from
#'   actual peaks against averaged background K-mer counts using a specified method.
#'
#' @param peak_kmer_counts_df A data frame with 'MOTIF' and 'COUNT' columns,
#'   representing K-mer counts from the primary (e.g., peak) sequences. Typically
#'   the output of `countKmers()`.
#' @param avg_bkg_counts_df A data frame with 'MOTIF' and 'AVG_BKG_COUNT' columns,
#'   representing averaged K-mer counts from background regions. Typically the
#'   output of `countKmersBkg()`.
#' @param method Character string (case-insensitive) specifying the enrichment
#'   calculation method. Supported: "subtract" (default), "fold_change",
#'   "log2_fold_change".
#' @param pseudocount Numeric, a small value added to both peak and background
#'   counts when using "fold_change" or "log2_fold_change" methods to avoid
#'   division by zero or log of zero. Default: 1.
#'
#' @return A data frame with 'MOTIF' and 'EnrichmentScore' columns.
#'
#' @importFrom dplyr full_join select mutate arrange desc %>%
#' @keywords internal # Helper for the main motifEnrichment function
calEnrichment <- function(peak_kmer_counts_df, avg_bkg_counts_df,
                          method = "subtract", pseudocount = 1) {
  # Input Validation
  if (!is.data.frame(peak_kmer_counts_df) || !all(c("MOTIF", "COUNT") %in% colnames(peak_kmer_counts_df))) {
    stop("'peak_kmer_counts_df' must be a data frame with 'MOTIF' and 'COUNT' columns.")
  }
  if (!is.data.frame(avg_bkg_counts_df) || !all(c("MOTIF", "AVG_BKG_COUNT") %in% colnames(avg_bkg_counts_df))) {
    stop("'avg_bkg_counts_df' must be a data frame with 'MOTIF' and 'AVG_BKG_COUNT' columns.")
  }
  if (!is.character(method) || length(method) != 1) {
    stop("'method' must be a single character string.")
  }
  if (!is.numeric(pseudocount) || length(pseudocount) != 1 || pseudocount < 0) {
    stop("'pseudocount' must be a single non-negative number.")
  }

  method_upper <- toupper(method)

  # Merge peak and background counts. Use inner_join to ensure only motifs present in both are kept,
  # or left_join from peaks if we want to keep all peak motifs and assign NA/0 to missing bkg.
  # For enrichment, usually, we're interested in motifs found in peaks.
  # countKmers and countKmersBkg should produce all possible K-mers, so MOTIF column should be exhaustive.
  # An inner_join is safest if there's any doubt about motif list completeness.
  # A full_join then handling NAs might be more robust if one df could miss motifs.
  # Let's assume both DFs have the complete set of motifs generated by countKmers.

  # For robustness, ensure MOTIF columns are character
  peak_kmer_counts_df$MOTIF <- as.character(peak_kmer_counts_df$MOTIF)
  avg_bkg_counts_df$MOTIF <- as.character(avg_bkg_counts_df$MOTIF)

  # A full join is better to handle cases where one set might be missing motifs (shouldn't happen ideally)
  # or if the order is not guaranteed identical (though it should be from countKmers).
  # Replace NAs that might arise from join with 0 for counts.
  merged_counts <- dplyr::full_join(peak_kmer_counts_df, avg_bkg_counts_df, by = "MOTIF")
  merged_counts$COUNT[is.na(merged_counts$COUNT)] <- 0
  merged_counts$AVG_BKG_COUNT[is.na(merged_counts$AVG_BKG_COUNT)] <- 0


  enriched_df <- switch(method_upper,
    "SUBTRACT" = {
      merged_counts %>%
        dplyr::mutate(EnrichmentScore = COUNT - AVG_BKG_COUNT) %>%
        dplyr::select(MOTIF, EnrichmentScore)
    },
    "FOLD_CHANGE" = {
      merged_counts %>%
        dplyr::mutate(EnrichmentScore = (COUNT + pseudocount) / (AVG_BKG_COUNT + pseudocount)) %>%
        dplyr::select(MOTIF, EnrichmentScore)
    },
    "LOG2_FOLD_CHANGE" = {
      merged_counts %>%
        dplyr::mutate(EnrichmentScore = log2((COUNT + pseudocount) / (AVG_BKG_COUNT + pseudocount))) %>%
        dplyr::select(MOTIF, EnrichmentScore)
    },
    stop(
      "Unsupported enrichment 'method': ", method,
      ". Supported methods are 'subtract', 'fold_change', 'log2_fold_change'."
    )
  )

  # Optionally, arrange by score
  # enriched_df <- enriched_df %>% dplyr::arrange(dplyr::desc(EnrichmentScore))

  return(enriched_df)
}

#' Calculate K-mer Motif Enrichment from Genomic Coordinates
#'
#' @description
#' This is the main workflow function for the RBPSpecificity package. It processes
#' RBP binding peak data (e.g., from eCLIP experiments) to calculate normalized,
#' background-corrected enrichment scores for all K-mers of a given length.
#'
#' @details
#' The workflow proceeds as follows:
#' 1.  Parses input coordinate data into a standardized GRanges object.
#' 2.  Loads the specified BSgenome object for sequence retrieval.
#' 3.  Extracts sequences for peak regions, applying optional extension/trimming.
#' 4.  Counts K-mers within the peak sequences.
#' 5.  Generates an averaged K-mer profile from multiple background sets. Background
#'     sets are created by shifting and scrambling genomic regions.
#' 6.  Calculates enrichment scores by comparing peak counts to background counts.
#' 7.  Normalizes the final enrichment scores to a standard scale.
#'
#' @param coordinates A data frame or GRanges object containing genomic coordinates.
#'   If a data frame, it must contain columns for chromosome, start, and end.
#' @param species_or_build Character string identifying the genome build (e.g.,
#'   "hg38", "mm10"). This is used to load the appropriate BSgenome package.
#' @param K Integer, the length of the K-mers to analyze (e.g., 5).
#' @param extension A numeric vector of length 2: `c(five_prime, three_prime)`.
#'   Positive values extend, negative values trim. Extension/trimming is strand-aware.
#'   Default: `c(0, 0)` (no change).
#' @param enrichment_method Character string, the method for calculating enrichment.
#'   Supported: "subtract" (default), "fold_change", "log2_fold_change".
#' @param normalization_method Character string, the method for normalizing the final
#'   enrichment scores. Supported: "min_max" (default), "z_score", "log2", "none".
#' @param log_transform Logical, if TRUE, applies a log transformation after scaling,
#'   mimicking the original analysis script's method (min-max to [1,e] then log).
#'   If FALSE, performs only the specified `normalization_method`. Default: TRUE.
#' @param bkg_iter Integer, the number of background iterations to perform for averaging.
#'   Default: 100.
#' @param bkg_min_dist Integer, the minimum distance (in base pairs) to shift peaks when
#'   creating background regions. Default: 500.
#' @param bkg_max_dist Integer, the maximum distance for shifting peaks. Default: 1000.
#' @param scramble_bkg Logical, if TRUE (default), scrambles background sequences after
#'   shifting. Set to FALSE for faster execution when using local background only.
#' @param nucleic_acid_type Character string, "DNA" or "RNA". Determines the alphabet
#'   for K-mer generation. Default: "DNA".
#' @param background_type Character string, "local" (default) or "global".
#'   - "local": Generates background by shifting (and optionally scrambling) peak regions.
#'   - "global": Uses pre-calculated motif counts from specific genomic regions
#'     stored in the package (supporting K=4, 5, 6, 7).
#'   If `global_background_region` is explicitly provided, this defaults to "global".
#' @param global_background_region Character string, the region to use for global
#'   background. Supported: "WholeGenome" (default), "5UTR", "CDS", "3UTR", "introns", "exons".
#'   Providing this argument will automatically switch `background_type` to "global"
#'   unless otherwise specified.
#' @param ... Additional arguments passed to `normalizeScores()` (e.g., `a=0, b=1`
#'   for min-max normalization).
#'
#' @return A data frame containing two columns: 'MOTIF' (all possible K-mers) and
#'   'Score' (the final, normalized enrichment score).
#' @export
#'
#' @examples
#' \dontrun{
#' # Option 1: Using Local Background (default, with scrambling)
#' res_local <- motifEnrichment(my_coords, "hg38", K = 5)
#'
#' # Option 2: Using Local Background without scrambling (faster)
#' res_local_fast <- motifEnrichment(my_coords, "hg38", K = 5, scramble_bkg = FALSE)
#'
#' # Option 3: Using Global Background (automatically switched by providing region)
#' res_global <- motifEnrichment(my_coords, "hg38", K = 5, global_background_region = "5UTR")
#'
#' # Option 4: Explicit Global Background
#' res_global_explicit <- motifEnrichment(
#'   coordinates = my_coords,
#'   species_or_build = "hg38",
#'   K = 5,
#'   background_type = "global"
#' )
#' }
motifEnrichment <- function(coordinates,
                            species_or_build,
                            K,
                            extension = c(0, 0),
                            enrichment_method = "subtract",
                            normalization_method = "min_max",
                            log_transform = TRUE,
                            bkg_iter = 100,
                            bkg_min_dist = 500,
                            bkg_max_dist = 1000,
                            scramble_bkg = TRUE,
                            nucleic_acid_type = "DNA",
                            background_type = "local",
                            global_background_region = "WholeGenome",
                            ...) {
  # --- 1. Input Validation and Logic Setup ---
  # If the user provided a global region but didn't specify background_type,
  # assume they want global background.
  if (!missing(global_background_region) && missing(background_type)) {
    background_type <- "global"
  }

  message("--- Phase 1: Initializing and Validating Inputs ---")
  if (missing(coordinates) || missing(species_or_build) || missing(K)) {
    stop("Arguments 'coordinates', 'species_or_build', and 'K' are required.")
  }

  # Validate extension parameter
  if (!is.numeric(extension) || length(extension) != 2) {
    stop("'extension' must be a numeric vector of length 2: c(five_prime, three_prime).")
  }
  extension <- as.integer(extension)

  # Load genome object
  genome_obj <- selectGenome(species_or_build)
  message("Successfully loaded genome: ", species_or_build)

  # Parse coordinate data into GRanges
  peak_gr <- peakParse(input = coordinates)
  if (length(peak_gr) == 0) {
    stop("Coordinate data is empty after parsing and filtering. Cannot proceed.")
  }
  message("Successfully parsed ", length(peak_gr), " coordinates.")

  # --- 2. Peak Sequence Processing ---
  message("\n--- Phase 2: Processing Peak Sequences ---")
  peak_sequences <- getSequence(
    granges_obj = peak_gr,
    genome_obj = genome_obj,
    extension = extension,
    min_length = K
  )
  if (length(peak_sequences) == 0) {
    stop("No sequences retrieved from coordinates. Check coordinates and chromosome names.")
  }
  message("Retrieved ", length(peak_sequences), " sequences from coordinate regions.")

  # Count K-mers in peaks
  peak_kmer_counts <- countKmers(
    sequences = peak_sequences,
    K = K,
    type = nucleic_acid_type
  )
  message("Counted K-mers in peak sequences. Found ", sum(peak_kmer_counts$COUNT > 0), " non-zero K-mers.")

  # --- 3. Background Calculation ---
  message("\n--- Phase 3: Generating Background Profile ---")
  background_type_lower <- tolower(background_type)

  if (background_type_lower == "local") {
    bkg_kmer_counts <- countKmersBkg(
      original_peak_gr = peak_gr,
      K = K,
      type = nucleic_acid_type,
      genome_obj = genome_obj,
      bkg_min_dist = bkg_min_dist,
      bkg_iter = bkg_iter,
      bkg_max_dist = bkg_max_dist,
      scramble_bkg = scramble_bkg
    )
    if (scramble_bkg) {
      message("Generated average background K-mer profile using local shifting with scrambling.")
    } else {
      message("Generated average background K-mer profile using local shifting (no scrambling).")
    }
  } else if (background_type_lower == "global") {
    bkg_file <- paste0("motif_counts_", K, "mer.txt")

    # Resolve path: first check installed package, then local development folder
    bkg_path <- system.file("extdata", bkg_file, package = "RBPSpecificity")
    if (bkg_path == "") {
      # Fallback for local development/testing before installation
      bkg_path <- file.path("inst", "extdata", bkg_file)
    }

    if (!file.exists(bkg_path)) {
      stop("Global background file '", bkg_file, "' not found in inst/extdata or package extdata.")
    }

    message("Loading global background from '", bkg_path, "' for region: ", global_background_region)
    bkg_data <- utils::read.table(bkg_path, header = TRUE, sep = "\t", stringsAsFactors = FALSE, check.names = FALSE)

    if (!(global_background_region %in% colnames(bkg_data))) {
      stop(
        "Region '", global_background_region, "' not found in global background file. ",
        "Available regions: ", paste(colnames(bkg_data)[-1], collapse = ", ")
      )
    }

    bkg_kmer_counts <- data.frame(
      MOTIF = bkg_data$Motif,
      AVG_BKG_COUNT = bkg_data[[global_background_region]],
      stringsAsFactors = FALSE
    )

    # Convert motifs to RNA if requested
    if (toupper(nucleic_acid_type) == "RNA") {
      bkg_kmer_counts$MOTIF <- gsub("T", "U", bkg_kmer_counts$MOTIF)
    }

    message("Successfully loaded global background profile.")
  } else {
    stop("Invalid 'background_type': must be 'local' or 'global'.")
  }

  # --- 4. Enrichment and Normalization ---
  message("\n--- Phase 4: Calculating Final Enrichment Scores ---")
  enrichment_scores <- calEnrichment(peak_kmer_counts_df = peak_kmer_counts, avg_bkg_counts_df = bkg_kmer_counts, method = enrichment_method)
  message("Calculated enrichment using '", enrichment_method, "' method.")

  if (log_transform) {
    message("Applying log-transformation to scores (scaling to [1,e] then taking natural log).")
    scores_scaled_to_exp <- normalizeScores(enrichment_scores$EnrichmentScore, method = "min_max", a = 1, b = exp(1))
    final_scores <- log(scores_scaled_to_exp)
  } else {
    message("Applying direct '", normalization_method, "' normalization.")
    # This is the old, direct normalization method
    final_scores <- normalizeScores(scores = enrichment_scores$EnrichmentScore, method = normalization_method, ...)
  }

  # --- 5. Return Final Data Frame ---
  results_df <- data.frame(
    MOTIF = enrichment_scores$MOTIF,
    Score = final_scores
  )

  # In case normalization produced NaNs (e.g., z-score on constant values), replace with 0
  results_df$Score[is.nan(results_df$Score)] <- 0

  message("\n--- Workflow Complete ---")
  return(results_df)
}

#-------------------------------------------------------------------------------
