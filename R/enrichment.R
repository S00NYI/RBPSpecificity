# Functions related to calculating K-mer motif enrichment from peak data.

#' Calculate Average K-mer Counts from Background Sets
#'
#' @description This function calculates the average K-mer counts over multiple
#'   iterations of background sequence generation. For each iteration, it generates
#'   a new set of background sequences using `generateBkgSet`, counts K-mers
#'   using `countKmers`, and then averages these counts across all iterations.
#'
#' @param original_peak_gr A GRanges object representing the initial peaks from
#'   which background regions are derived.
#' @param K Integer, the length of K-mers to count.
#' @param type Character string, "DNA" or "RNA" (case-insensitive), defining the
#'   alphabet for K-mer generation. Passed to `countKmers` and used to
#'   generate the K-mer universe. Default: "DNA".
#' @param genome_obj A BSgenome object for sequence retrieval by `generateBkgSet`.
#' @param Bkg_dist Integer, the minimum absolute distance (in base pairs) for
#'   shifting peaks. Passed to `generateBkgSet`. Default: 500.
#' @param Bkg_number Integer, the number of background iterations to perform.
#'   Default: 100.
#' @param max_shift_dist Integer, the maximum absolute distance (in base pairs)
#'   for shifting peaks. Passed to `generateBkgSet`. Default: 1000.
#' @param internal_min_length_for_bkg_seqs Integer, minimum length for sequences
#'   generated by `generateBkgSet` (passed as `K` to `generateBkgSet` which
#'   passes it as `min_length` to `getSequence`). Default is `K` from this function.
#'
#' @return A data frame with two columns: 'MOTIF' (all possible K-mers for the
#'   specified type and K, in uppercase) and 'AVG_BKG_COUNT' (the average count
#'   of each K-mer across all background iterations, rounded).
#'   Returns a data frame with 0 counts if no valid background sequences
#'   could be generated across all iterations.
#'
#' @importFrom Biostrings DNAStringSet
#' @importFrom S4Vectors elementNROWS
#' @importFrom utils txtProgressBar setTxtProgressBar
#' @importFrom methods is
#'
#' @keywords internal # Helper for the main motifEnrichment function
countKmersBkg <- function(original_peak_gr, K, type = "DNA", genome_obj,
                          Bkg_dist = 500, Bkg_number = 100, max_shift_dist = 1000,
                          internal_min_length_for_bkg_seqs = K) {

  # Input Validation for parameters specific to this function
  if (!methods::is(original_peak_gr, "GRanges") || length(original_peak_gr) == 0) {
    stop("'original_peak_gr' must be a non-empty GRanges object.")
  }
  # K, type, genome_obj, Bkg_dist, max_shift_dist will be validated by downstream functions
  # like countKmers, generateBkgSet, genRNDist.
  if (!is.numeric(Bkg_number) || length(Bkg_number) != 1 || Bkg_number <= 0 || Bkg_number %% 1 != 0) {
    stop("'Bkg_number' must be a single positive integer.")
  }
  if (!is.numeric(internal_min_length_for_bkg_seqs) || length(internal_min_length_for_bkg_seqs) != 1 ||
      internal_min_length_for_bkg_seqs < 1 || internal_min_length_for_bkg_seqs %% 1 != 0) {
    stop("'internal_min_length_for_bkg_seqs' must be a single positive integer.")
  }
  if (internal_min_length_for_bkg_seqs < K) {
    warning("'internal_min_length_for_bkg_seqs' (", internal_min_length_for_bkg_seqs,
            ") is less than K (", K, "). Background sequences might be too short for K-mer counting.")
  }

  message("Note: During background generation, any regions shorter than K=", K, " will be removed.")

  # Get the template of all possible K-mers to define rows and order
  # Call countKmers with an empty DNAStringSet to get the MOTIF column structure
  template_kmers_df <- countKmers(sequences = Biostrings::DNAStringSet(), K = K, type = type)
  all_kmers_vector <- template_kmers_df$MOTIF

  if (length(all_kmers_vector) == 0 && K > 0) { # K=0 is invalid, caught by countKmers
    stop("Could not generate the K-mer universe template. Check K and type parameters for countKmers.")
  }

  # Matrix to store K-mer counts for each iteration
  # Rows: K-mers, Columns: Iterations
  # Initialize with 0s. dimnames ensures row order matches all_kmers_vector.
  counts_accumulator_matrix <- matrix(0L,
                                      nrow = length(all_kmers_vector),
                                      ncol = Bkg_number,
                                      dimnames = list(all_kmers_vector, NULL))

  valid_iterations_count <- 0 # Track iterations that yielded actual sequences for counting

  message("Generating average background K-mer profile over ", Bkg_number, " iterations:")
  pb <- utils::txtProgressBar(min = 0, max = Bkg_number, style = 3)

  for (i in 1:Bkg_number) {
    # Generate one set of scrambled background sequences
    # K for generateBkgSet is its internal min_length for getSequence
    one_bkg_dna_set <- generateBkgSet(
      peak_gr = original_peak_gr,
      genome_obj = genome_obj,
      K = internal_min_length_for_bkg_seqs, # This K is for sequence length in getSequence
      Bkg_dist = Bkg_dist,
      max_shift_dist = max_shift_dist
    )

    # If sequences were generated, count K-mers
    if (length(one_bkg_dna_set) > 0) {
      # Check if all sequences in the set are long enough for K-mer counting
      # (generateBkgSet should ensure this via getSequence's min_length, but double check concept)
      # Actually, countKmers itself handles sequences shorter than K by not finding K-mers in them.
      iter_counts_df <- countKmers(sequences = one_bkg_dna_set, K = K, type = type) # This K is for K-mer counting

      # Ensure the motifs from iter_counts_df match the order in all_kmers_vector
      # (countKmers should always return them in a consistent order based on expand.grid)
      if (identical(iter_counts_df$MOTIF, all_kmers_vector)) {
        counts_accumulator_matrix[, i] <- iter_counts_df$COUNT
        if(sum(iter_counts_df$COUNT) > 0) { # Consider an iteration valid if it produced any counts
          valid_iterations_count <- valid_iterations_count + 1
        }
      } else {
        warning("Motif order mismatch in background iteration ", i, ". This should not happen. Counts for this iteration set to 0.")
        # Counts remain 0 for this column as initialized
      }
    } else {
      # No background sequences generated in this iteration, counts remain 0.
    }
    utils::setTxtProgressBar(pb, i)
  } # End of iterations loop
  close(pb)

  if (valid_iterations_count == 0 && Bkg_number > 0) {
    message("\nWarning: No valid background sequences yielded counts across any of the ", Bkg_number, " iterations. ",
            "Average background counts will be all zeros.")
    # The matrix is already initialized with zeros, so rowMeans will be 0.
  } else if (Bkg_number > 0) {
    message("\nBackground profile generated. Averaged over ", valid_iterations_count,
            " iterations that yielded sequences with K-mer counts.")
  }


  # Calculate average counts across all iterations
  # If an iteration yielded no sequences, its column in counts_accumulator_matrix is 0.
  # This correctly contributes to the average.
  average_counts <- rowMeans(counts_accumulator_matrix, na.rm = FALSE) # Should be no NAs if initialized with 0L

  results_df <- data.frame(
    MOTIF = all_kmers_vector,
    AVG_BKG_COUNT = round(average_counts, 4), # Round for tidiness
    stringsAsFactors = FALSE
  )

  return(results_df)
}


#' Calculate Background-Corrected K-mer Enrichment
#'
#' @description Calculates enrichment scores by comparing K-mer counts from
#'   actual peaks against averaged background K-mer counts using a specified method.
#'
#' @param peak_kmer_counts_df A data frame with 'MOTIF' and 'COUNT' columns,
#'   representing K-mer counts from the primary (e.g., peak) sequences. Typically
#'   the output of `countKmers()`.
#' @param avg_bkg_counts_df A data frame with 'MOTIF' and 'AVG_BKG_COUNT' columns,
#'   representing averaged K-mer counts from background regions. Typically the
#'   output of `countKmersBkg()`.
#' @param method Character string (case-insensitive) specifying the enrichment
#'   calculation method. Supported: "subtract" (default), "fold_change",
#'   "log2_fold_change".
#' @param pseudocount Numeric, a small value added to both peak and background
#'   counts when using "fold_change" or "log2_fold_change" methods to avoid
#'   division by zero or log of zero. Default: 1.
#'
#' @return A data frame with 'MOTIF' and 'EnrichmentScore' columns.
#'
#' @importFrom dplyr inner_join select mutate arrange desc
#' @keywords internal # Helper for the main motifEnrichment function
calEnrichment <- function(peak_kmer_counts_df, avg_bkg_counts_df,
                          method = "subtract", pseudocount = 1) {

  # Input Validation
  if (!is.data.frame(peak_kmer_counts_df) || !all(c("MOTIF", "COUNT") %in% colnames(peak_kmer_counts_df))) {
    stop("'peak_kmer_counts_df' must be a data frame with 'MOTIF' and 'COUNT' columns.")
  }
  if (!is.data.frame(avg_bkg_counts_df) || !all(c("MOTIF", "AVG_BKG_COUNT") %in% colnames(avg_bkg_counts_df))) {
    stop("'avg_bkg_counts_df' must be a data frame with 'MOTIF' and 'AVG_BKG_COUNT' columns.")
  }
  if (!is.character(method) || length(method) != 1) {
    stop("'method' must be a single character string.")
  }
  if (!is.numeric(pseudocount) || length(pseudocount) != 1 || pseudocount < 0) {
    stop("'pseudocount' must be a single non-negative number.")
  }

  method_upper <- toupper(method)

  # Merge peak and background counts. Use inner_join to ensure only motifs present in both are kept,
  # or left_join from peaks if we want to keep all peak motifs and assign NA/0 to missing bkg.
  # For enrichment, usually, we're interested in motifs found in peaks.
  # countKmers and countKmersBkg should produce all possible K-mers, so MOTIF column should be exhaustive.
  # An inner_join is safest if there's any doubt about motif list completeness.
  # A full_join then handling NAs might be more robust if one df could miss motifs.
  # Let's assume both DFs have the complete set of motifs generated by countKmers.

  # For robustness, ensure MOTIF columns are character
  peak_kmer_counts_df$MOTIF <- as.character(peak_kmer_counts_df$MOTIF)
  avg_bkg_counts_df$MOTIF <- as.character(avg_bkg_counts_df$MOTIF)

  # A full join is better to handle cases where one set might be missing motifs (shouldn't happen ideally)
  # or if the order is not guaranteed identical (though it should be from countKmers).
  # Replace NAs that might arise from join with 0 for counts.
  merged_counts <- dplyr::full_join(peak_kmer_counts_df, avg_bkg_counts_df, by = "MOTIF")
  merged_counts$COUNT[is.na(merged_counts$COUNT)] <- 0
  merged_counts$AVG_BKG_COUNT[is.na(merged_counts$AVG_BKG_COUNT)] <- 0


  enriched_df <- switch(
    method_upper,
    "SUBTRACT" = {
      merged_counts %>%
        dplyr::mutate(EnrichmentScore = COUNT - AVG_BKG_COUNT) %>%
        dplyr::select(MOTIF, EnrichmentScore)
    },
    "FOLD_CHANGE" = {
      merged_counts %>%
        dplyr::mutate(EnrichmentScore = (COUNT + pseudocount) / (AVG_BKG_COUNT + pseudocount)) %>%
        dplyr::select(MOTIF, EnrichmentScore)
    },
    "LOG2_FOLD_CHANGE" = {
      merged_counts %>%
        dplyr::mutate(EnrichmentScore = log2((COUNT + pseudocount) / (AVG_BKG_COUNT + pseudocount))) %>%
        dplyr::select(MOTIF, EnrichmentScore)
    },
    stop("Unsupported enrichment 'method': ", method,
         ". Supported methods are 'subtract', 'fold_change', 'log2_fold_change'.")
  )

  # Optionally, arrange by score
  # enriched_df <- enriched_df %>% dplyr::arrange(dplyr::desc(EnrichmentScore))

  return(enriched_df)
}

#' Calculate K-mer Motif Enrichment from Peak Data
#'
#' @description
#' This is the main workflow function for the RBPSpecificity package. It processes
#' RBP binding peak data (e.g., from eCLIP experiments) to calculate normalized,
#' background-corrected enrichment scores for all K-mers of a given length.
#'
#' @details
#' The workflow proceeds as follows:
#' 1.  Parses input peak data into a standardized GRanges object.
#' 2.  Loads the specified BSgenome object for sequence retrieval.
#' 3.  Extracts sequences for peak regions, applying an optional 5'-end extension.
#' 4.  Counts K-mers within the peak sequences.
#' 5.  Generates an averaged K-mer profile from multiple background sets. Background
#'     sets are created by shifting and scrambling genomic regions.
#' 6.  Calculates enrichment scores by comparing peak counts to background counts.
#' 7.  Normalizes the final enrichment scores to a standard scale.
#'
#' @param peak_data A data frame or GRanges object containing peak data. If a
#'   data frame, it must contain columns for chromosome, start, and end coordinates.
#' @param species_or_build Character string identifying the genome build (e.g.,
#'   "hg38", "mm10"). This is used to load the appropriate BSgenome package.
#' @param K Integer, the length of the K-mers to analyze (e.g., 5).
#' @param extension Integer, the number of base pairs to extend each peak from its
#'   5'-end (upstream). Default: 0.
#' @param enrichment_method Character string, the method for calculating enrichment.
#'   Supported: "subtract" (default), "fold_change", "log2_fold_change".
#' @param normalization_method Character string, the method for normalizing the final
#'   enrichment scores. Supported: "min_max" (default), "z_score", "log2", "none".
#' @param Bkg_number Integer, the number of background iterations to perform for averaging.
#'   Default: 100.
#' @param Bkg_dist Integer, the minimum distance (in base pairs) to shift peaks when
#'   creating background regions. Default: 500.
#' @param max_shift_dist Integer, the maximum distance for shifting peaks. Default: 1000.
#' @param nucleic_acid_type Character string, "DNA" or "RNA". Determines the alphabet
#'   for K-mer generation. Default: "DNA".
#' @param ... Additional arguments passed to `normalizeScores()` (e.g., `a=0, b=1`
#'   for min-max normalization).
#'
#' @return A data frame containing two columns: 'MOTIF' (all possible K-mers) and
#'   'Score' (the final, normalized enrichment score).
#' @export
#'
#' @examples
#' \dontrun{
#' # This is a conceptual example, as it requires real data and a BSgenome package.
#' # Assume 'my_peak_df' is a data frame with chr, start, end columns.
#'
#' enrichment_results <- motifEnrichment(
#'   peak_data = my_peak_df,
#'   species_or_build = "hg38",
#'   K = 5,
#'   extension = 25,
#'   enrichment_method = "subtract",
#'   normalization_method = "min_max"
#' )
#'
#' head(enrichment_results)
#' }
motifEnrichment <- function(peak_data,
                            species_or_build,
                            K,
                            extension = 0,
                            enrichment_method = "subtract",
                            normalization_method = "min_max",
                            Bkg_number = 100,
                            Bkg_dist = 500,
                            max_shift_dist = 1000,
                            nucleic_acid_type = "DNA",
                            ...) {

  # --- 1. Input Validation and Setup ---
  message("--- Phase 1: Initializing and Validating Inputs ---")
  if (missing(peak_data) || missing(species_or_build) || missing(K)) {
    stop("Arguments 'peak_data', 'species_or_build', and 'K' are required.")
  }

  # Load genome object
  genome_obj <- selectGenome(species_or_build)
  message("Successfully loaded genome: ", species_or_build)

  # Parse peak data into GRanges
  peak_gr <- peakParse(input = peak_data)
  if (length(peak_gr) == 0) {
    stop("Peak data is empty after parsing and filtering. Cannot proceed.")
  }
  message("Successfully parsed ", length(peak_gr), " peaks.")

  # --- 2. Peak Sequence Processing ---
  message("\n--- Phase 2: Processing Peak Sequences ---")
  peak_sequences <- getSequence(
    granges_obj = peak_gr,
    genome_obj = genome_obj,
    extension = extension,
    min_length = K
  )
  if (length(peak_sequences) == 0) {
    stop("No sequences retrieved from peaks. Check peak coordinates and chromosome names.")
  }
  message("Retrieved ", length(peak_sequences), " sequences from peak regions.")

  # Count K-mers in peaks
  peak_kmer_counts <- countKmers(
    sequences = peak_sequences,
    K = K,
    type = nucleic_acid_type
  )
  message("Counted K-mers in peak sequences. Found ", sum(peak_kmer_counts$COUNT > 0), " non-zero K-mers.")

  # --- 3. Background Calculation ---
  message("\n--- Phase 3: Generating Background Profile ---")
  bkg_kmer_counts <- countKmersBkg(
    original_peak_gr = peak_gr,
    K = K,
    type = nucleic_acid_type,
    genome_obj = genome_obj,
    Bkg_dist = Bkg_dist,
    Bkg_number = Bkg_number,
    max_shift_dist = max_shift_dist
  )
  message("Generated average background K-mer profile.")

  # --- 4. Enrichment and Normalization ---
  message("\n--- Phase 4: Calculating Final Enrichment Scores ---")
  # Calculate background-corrected enrichment
  enrichment_scores <- calEnrichment(
    peak_kmer_counts_df = peak_kmer_counts,
    avg_bkg_counts_df = bkg_kmer_counts,
    method = enrichment_method
  )
  message("Calculated enrichment using '", enrichment_method, "' method.")

  # Normalize the final scores
  final_scores <- normalizeScores(
    scores = enrichment_scores$EnrichmentScore,
    method = normalization_method,
    ...
  )
  message("Normalized final scores using '", normalization_method, "' method.")

  # --- 5. Return Final Data Frame ---
  results_df <- data.frame(
    MOTIF = enrichment_scores$MOTIF,
    Score = final_scores
  )

  # In case normalization produced NaNs (e.g., z-score on constant values), replace with 0
  results_df$Score[is.nan(results_df$Score)] <- 0

  message("\n--- Workflow Complete ---")
  return(results_df)
}

#-------------------------------------------------------------------------------
